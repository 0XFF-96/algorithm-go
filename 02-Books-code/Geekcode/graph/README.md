### 图主要有两种存储方法
    1、邻接表 2、接邻矩阵
    
## 图的主要数据接口实现
>  https://flaviocopes.com/golang-data-structure-graph/
-  接邻矩阵的实现：http://tobin.cc/blog/graph/
- 接邻表的实现
不同的实现之间有三种区别：
  1、如何表示图
  2、如何表示节点
  3、如何表示边

### 不同实现有什么优缺点
- 基本属性：图的节点、边、权值、有向无向和强弱连通性等基础概念
- 使用邻接矩阵将十分方便的查询连通性，较少的浪费存储空间。邻接表将查找麻烦
- https://juejin.im/entry/5b3099ebe51d4558d05eff72

    visited是用来记录已经被访问的顶点，用来避免顶点被重复访问。
    如果顶点q被访问，那相应的visited[q]会 被设置为true。
    queue是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。
    因为广度优先搜索是逐层访 问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第k+1层的顶点。当我们访问到第k层 的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第k+1层的顶点。所以， 我们用这个队列来实现记录的功能。
    prev用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，
    prev数组中存储的就是搜索的路 径。不过，这个路径是反向存储的。
    prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。
    比如，我们 通过顶点2的邻接表访问到顶点3，那prev[3]就等于2。
    为了正向打印出路径，我们需要递归地来打印，你可 以看下print()函数的实现方式

    Youtube 图系列：https://www.youtube.com/watch?v=ddTC4Zovtbc&list=PLrmLmBdmIlpu2f2g8ltqaaCZiq6GJvl1j
    一个图基本有以下实现


    